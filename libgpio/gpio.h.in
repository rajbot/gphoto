#ifndef _GPIO_H_
#define _GPIO_H_

#include "gpio-serial.h"

#include "gpio-parallel.h"

#include "gpio-socket.h"

#if @GPIO_USB@
#define GPIO_USB
#endif

#if @GPIO_IEEE1394@
#define GPIO_IEEE1394
#endif

#ifdef GPIO_USB
#include <usb.h>
#include "gpio-usb.h"
#endif

#ifdef GPIO_IEEE1394
#include "gpio-ieee1394.h"
#endif


#ifndef TRUE
#define TRUE (0==0)
#endif

#ifndef FALSE
#define FALSE (1==0)
#endif

/* Defines and enums
   -------------------------------------------------------------- */

#define GPIO_MAX_BUF_LEN 4096 		/* max length of receive buffer */


#define GPIO_OK		0
#define	GPIO_ERROR	-1		/* IO return codes */
#define GPIO_TIMEOUT    -2

/* Specify the types of devices */
typedef enum {
	GPIO_DEVICE_SERIAL,
	GPIO_DEVICE_PARALLEL,	/* <- Not supported yet */
	GPIO_DEVICE_SOCKET,
#ifdef GPIO_USB
	GPIO_DEVICE_USB,
#endif
#ifdef GPIO_IEEE1394
	GPIO_DEVICE_1394, 	/* <- Not supported yet */
#endif
} gpio_device_type;



/* Device struct
   -------------------------------------------------------------- */
typedef struct {
	gpio_device_type type;
	char name[64];
	char path[64];
} gpio_device_info;

/* Put the settings together in a union */
typedef union {
	gpio_serial_settings	serial;
	gpio_parallel_settings	parallel;
	gpio_socket_settings	socket;
#ifdef GPIO_USB
	gpio_usb_settings 	usb;
#endif
#ifdef GPIO_IEEE1394
	gpio_ieee1394_settings 	ieee1394;
#endif

} gpio_device_settings;


struct gpio_device;
typedef struct gpio_device gpio_device;
struct gpio_operations {
	int (*list)	(gpio_device_info *, int*);
	int (*init)	(gpio_device *);
	int (*exit)	(gpio_device *);
	int (*open)	(gpio_device *);
	int (*close)	(gpio_device *);
	int (*read)	(gpio_device *, char *, int);
	int (*write)	(gpio_device *, char *, int);
	int (*get_pin)	(gpio_device *, int);
	int (*set_pin)	(gpio_device *, int, int);
	int (*update) (gpio_device *);
};

/* Specify the device information */
struct gpio_device {
	/* This struct is available via wrappers. don't modify 
	   directly. */
        gpio_device_type type;

	struct gpio_operations *ops;

	gpio_device_settings settings;
	gpio_device_settings settings_pending;

	gpio_device_settings settings_saved;

	int device_fd;
	void *device_handle;
	int timeout; /* in milli seconds */
};

/* gpio Core functions
   -------------------------------------------------------------- */

	int gpio_init		();
		/* Initializes the library
			return values:
				  successful: GPIO_OK
				unsuccessful: GPIO_ERROR
		*/

int	     gpio_get_device_count ();
		/* Get a count of available devices
			return values:
				  successful: valid gpio_device_list struct
				unsuccessful: GPIO_ERROR
		*/

int	     gpio_get_device_info (int device_number, gpio_device_info *info);
		/* Get information about a device
			return values:
				  successful: valid gpio_device_list struct
				unsuccessful: GPIO_ERROR
		*/

gpio_device *gpio_new		(gpio_device_type type);
		/* Create a new device of type "type"
			return values:
				  successful: valid gpio_device struct
				unsuccessful: GPIO_ERROR
		*/

gpio_device *gpio_new_by_number (int device_number);
		/* Create a new device from the enumerate device listing
			return values:
				  successful: valid gpio_device struct
				unsuccessful: GPIO_ERROR
		*/


gpio_device *gpio_new_by_port (char *device_port);
		/* Create a new device from the enumerate device listing
			return values:
				  successful: valid gpio_device struct
				unsuccessful: GPIO_ERROR
		*/

	int gpio_free      	(gpio_device *dev);
		/* Frees an IO device from memory
			return values:
				  successful: GPIO_OK
				unsuccessful: GPIO_ERROR
		*/


	int gpio_open       	(gpio_device *dev);
		/* Open the device for reading and writing
			return values:
				  successful: GPIO_OK
				unsuccessful: GPIO_ERROR
		*/

	int gpio_close      	(gpio_device *dev);
		/* Close the device to prevent reading and writing
			return values:
				  successful: GPIO_OK
				unsuccessful: GPIO_ERROR
		*/

       int gpio_set_timeout 	(gpio_device *dev, int millisec_timeout);
		/* Sets the read/write timeout
				  successful: GPIO_OK
				unsuccessful: GPIO_ERROR
		*/

       int gpio_get_timeout 	(gpio_device *dev, int *millisec_timeout);
		/* Sets the read/write timeout
				  successful: GPIO_OK
				unsuccessful: GPIO_ERROR
		*/

       int gpio_set_settings 	(gpio_device *dev, 
				 gpio_device_settings settings);
		/* Sets the settings
				  successful: GPIO_OK
				unsuccessful: GPIO_ERRO
		*/


       int gpio_get_settings 	(gpio_device *dev, 
				 gpio_device_settings *settings);
		/* Returns settings in "settings"
				  successful: GPIO_OK
				unsuccessful: GPIO_ERROR
		*/

       int gpio_write 		(gpio_device *dev, char *bytes, int size);
		/* Writes "bytes" of size "size" to the device
			return values:
				  successful: GPIO_OK
				unsuccessful: GPIO_ERROR
		*/

       int gpio_read		(gpio_device *dev, char *bytes, int size);
		/* Reads "size" bytes in to "bytes" from the device
			return values:
				  successful: number of bytes read
				unsuccessful: GPIO_ERROR
		*/

		int gpio_get_pin   (gpio_device *dev, int pin);
		/* Give the status of pin from dev
			pin values:
				 see PIN_ constants in the various .h files	
			return values:
				  successful: status
				unsuccessful: GPIO_ERROR
		not implemented for USB (useful?)
		*/

		int gpio_set_pin   (gpio_device *dev, int pin, int level);
		/* set the status of pin from dev to level
			pin values:
				 see PIN_ constants in the various .h files	
			level values:
					0 for off
					1 for on
			return values:
				  successful: status
				unsuccessful: GPIO_ERROR
		not implemented for USB (useful?)
		*/

#endif /* _GPIO_H_ */
